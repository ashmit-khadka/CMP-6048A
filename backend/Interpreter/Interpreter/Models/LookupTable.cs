using Newtonsoft.Json;
using Newtonsoft.Json.Converters;
using System;
using System.Collections.Generic;
using System.ComponentModel;

namespace Interpreter.Models
{

	public class LookupTable
	{
		//These are the tokens that are used to classify each symbol
		[JsonConverter(typeof(StringEnumConverter))]
		public enum Tokens : int
		{
			[Description(" ")]
			EMPTY = -1,
			[Description("+")]
			Plus = 0,
			[Description("-")]
			Minus = 1,
			[Description("*")]
			Multiply = 2,
			[Description("/")]
			Divide = 3,
			[Description("^")]
			Exponent = 4,
			[Description("=")]
			Equal = 5,
			Left_Parenthesis = 7,
			Right_Parenthesis = 8,
			Integer = 9,
			Double = 10,
			Variable = 11

		}

		//This is the symbol table that is used
		public Symbol[] symbols { get; set; } 
		//This dictionary stores the name of the variable and either a double or int
		public Dictionary<String, object> variables { get; set; }
		//This stores the parse trie generated by the parser
		public ParseTree pt { get; set; }
		//Uses the MAX_TOKENS to decide how large the symbol table should be
		public int MAX_TOKENS { get; set; }
		//
		public List<string> operations = new List<string>();

		public LookupTable(int MAX_TOKENS)
		{
			this.MAX_TOKENS = MAX_TOKENS;
			InitSymbols();
			variables = new Dictionary<string, object>();
		}

		//Initialises the symbol table
		public void InitSymbols()
		{
			symbols = new Symbol[MAX_TOKENS];
		}

		//Allows to add symbols by index
		public void AddSymbol(int index, Tokens type, Object value)
		{
			symbols[index] = new Symbol(type, value);
		}

		//Allows for getting a symbol by index
		public Symbol GetSymbol(int index)
		{
			return symbols[index];
		}

		//Overwrites the current variable 
		public void UpdateVariable(string key, double value)
		{
			variables[key] = value;
		}

		//Gets the variable thats stored in the dictionary using key
		public double GetVarValue(string key)
		{
			return Convert.ToDouble(variables[key]);
		}

		//Adds a variable to the dictionary
		public void AddToVariables(string key, double v, bool isFromParseFunc)
		{
			try
			{
				variables.Add(key, v);
			}

			catch (Exception)
			{
				variables[key] = v;
			}
		}

		//Clears all variables
		public void ClearVariables()
		{
			variables.Clear();
		}

		//Checks if a variable exists in dictionary
		public bool VariableExist(string key)
		{
			return variables.ContainsKey(key);
		}

		//Sets the parsed trie 
		public void SetParsedTrie(ParseTree pt)
		{
			this.pt = pt;
		}

		//Struct that contains token and value
		public struct Symbol
		{
			public Symbol(Tokens type, object value)
			{
				this.Type = type;
				this.Value = value;
			}

			public Tokens Type { get; }
			public object Value { get; }

			public override string ToString()
			{
				return this.Type.ToString();
			}
		}
	}
}